---
title: 【IT技術の知見】ネットワーク＠マイクロサービスアーキテクチャ
description: ネットワーク＠マイクロサービスアーキテクチャの知見を記録しています。
---

# ネットワーク＠マイクロサービスアーキテクチャ

## はじめに

本サイトにつきまして、以下をご認識のほど宜しくお願いいたします。

> - https://hiroki-it.github.io/tech-notebook/

<br>

## 01. マイクロサービス間通信の方式

### リクエストリプライ方式

#### ▼ リクエストリプライ方式とは

![service_request_reply](https://raw.githubusercontent.com/hiroki-it/tech-notebook-images/master/images/service_request_reply.png)

マイクロサービス間で相互通信を実行する。

ドメインモデリングは、ステートソーシング方式になる。

送信側と受信側で通信処理が同時に実行されるため、HTTPやgRPCによる同期通信を実行することになる。

また、マイクロサービス間で直接的にリクエストを送受信することになる。

使用することのできる通信プロトコルは以下の通りである。

| プロコトル   | 説明                                                                                                                                                                                                                                                                                                                                                                                                         |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 従来のTCP/IP | 従来のTCP/IPプロトコルを使用する。                                                                                                                                                                                                                                                                                                                                                                           |
| gRPC         | HTTP/`1.1`に代わるHTTP/`2.0` (例：gRPCなど) を使用する。HTTPプロトコルであると、通信相手のマイクロサービスのエンドポイントをコールした後、エンドポイントに紐づくコントローラーのメソッドが実行される。一方でgRPCであると、通信相手のマイクロサービスのメソッドを直接的に実行できる。そのため、HTTPよりもマイクロサービスの連携に適している。<br>・https://techdozo.dev/grpc-for-microservices-communication/ |

> - https://qiita.com/yasuabe2613/items/3bff44e662c922083264#%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%83%B3%E3%82%B0%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%AE%E5%95%8F%E9%A1%8C%E9%A0%98%E5%9F%9F

#### ▼ ポイントツーポイントの場合

マイクロサービス間で直接的に通信する。

メッセージキューやメッセージブローカーを経由するよりも、各マイクロサービスの結合度が高まってしまう。

一方で、マイクロサービスの実装が簡単になる。

> - https://www.linkedin.com/pulse/microservice-integration-patterns-point-to-point-vs-message-rhodes-7sfoc/

#### ▼ メッセージキューやメッセージブローカーを経由する場合

メッセージキュー (例：AWS SQS、など) やメッセージブローカー (例：Apache Kafka、RabbitMQ、など) を経由して、マイクロサービス間で通信する。

宛先マイクロサービスが永続化の責務を担っている場合は、処理の開始/終了を担保して処理完了の確実性を担保したがいい。

そのため、リクエストリプライ方式であってもマイクロサービス間に双方向のメッセージブローカーを設置する。

例えば、リクエストリプライ方式でオーケストレーションベースSagaパターンを採用する場合がある。

Sagaサービスの後続マイクロサービスの間にメッセージブローカーを置くのは、後続マイクロサービスのローカルトランザクションを確実に完了するためである。

> - https://jackynote.medium.com/message-brokers-pros-cons-and-their-crucial-role-in-microservice-3dc6c0df2e53
> - https://www.linkedin.com/pulse/microservice-integration-patterns-point-to-point-vs-message-rhodes-7sfoc/

<br>

### イベント駆動方式

#### ▼ イベント駆動方式とは

![service_event_driven](https://raw.githubusercontent.com/hiroki-it/tech-notebook-images/master/images/service_event_driven.png)

マイクロサービスからマイクロサービスに一方通行で通信する。

ドメインモデリングは、イベントソーシング方式になる。

送信側と受信側で通信処理が独立して実行されるため、メッセージキューやメッセージブローカーを経由した非同期通信を実行することになる。

> - https://en.wikipedia.org/wiki/Message_queue
> - https://qiita.com/yasuabe2613/items/3bff44e662c922083264#%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%83%B3%E3%82%B0%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%AE%E5%95%8F%E9%A1%8C%E9%A0%98%E5%9F%9F

#### ▼ ポイントツーポイントの場合

このパターンは存在しない。

#### ▼ メッセージキューやメッセージブローカーを経由する場合

メッセージキュー (例：AWS SQS、など) やメッセージブローカー (例：Apache Kafka、RabbitMQ、など) を経由して、マイクロサービス間で通信する。

イベント駆動方式の場合は、各マイクロサービスは非同期で通信した方がよく、一方向のメッセージブローカーを設置する。

特に、複数のダウンストリーム側マイクロサービスからのリクエストを集約するようなアップストリーム側マイクロサービスがある場合、そのダウンストリームにメッセージブローカーを配置すれば、アップストリーム側マイクロサービスのレートリミットを超過しないように、一定の間隔で通信を転送できる。

もしマイクロサービス間双方向に送信したい場合は、ダウンストリーム側マイクロサービスからメッセージを受信するメッセージブローカーと、アップストリーム側マイクロサービスから受信するメッセージブローカーを、別々に配置する。

> - https://en.wikipedia.org/wiki/Message_queue
> - https://www.scaleuptech.com/de/blog/api-gateway-vs-service-mesh-vs-message-queue/

<br>

## 02. 通信に伴う処理

### タイムアウト時間

#### ▼ マイクロサービスだけに着目する場合

ダウンストリーム側マイクロサービスよりもアップストリーム側マイクロサービスのタイムアウト時間を短くする。

```yaml
マイクロサービス # 45秒
⬇⬆︎︎
⬇⬆︎︎︎︎
マイクロサービス # 30秒
⬇⬆︎︎
⬇⬆︎︎
マイクロサービス # 15秒
```

#### ▼ サイドカープロキシにも着目する場合

ダウンストリーム側マイクロサービスよりもサイドカーのタイムアウト時間を短くする。

また、サイドカーよりもアップストリーム側マイクロサービスのサイドカーのタイムアウト時間を短くする。

```yaml
アプリ # 45秒
⬇⬆︎︎
⬇⬆︎︎
サイドカー # 44秒
⬇⬆︎︎
-------------- # マイクロサービス間の境界
⬇⬆︎︎
サイドカー # 31秒
⬇⬆︎︎
⬇⬆︎︎
アプリ # 30秒
⬇⬆︎︎
⬇⬆︎︎
サイドカー # 29秒
⬇⬆︎︎
-------------- # マイクロサービス間の境界
⬇⬆︎︎
サイドカー # 16秒
⬇⬆︎︎
⬇⬆︎︎
アプリ # 15秒
```

<br>

## 03. 障害対策

### ロードバランシング

#### ▼ サーキットブレイカー

アップストリーム側マイクロサービスに障害が発生した時に、ダウンストリーム側マイクロサービスにエラーを返してしまわないよう、一旦マイクロサービスへのルーティングを停止し、直近の成功時の処理結果を返信する。

マイクロサービス間に配置され、他のマイクロサービスに連鎖的に起こる障害 (カスケード障害) を吸収する仕組みのこと。

blast-radiusを最小限にできる。

![circuit-breaker](https://raw.githubusercontent.com/hiroki-it/tech-notebook-images/master/images/circuit-breaker.png)

> - https://digitalvarys.com/what-is-circuit-breaker-design-pattern/

<br>
