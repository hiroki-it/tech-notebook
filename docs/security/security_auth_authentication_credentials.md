# 認証情報による分類＠認証

## はじめに

本サイトにつきまして、以下をご認識のほど宜しくお願いいたします。

> - https://hiroki-it.github.io/tech-notebook/

<br>

## 01. セッションベース認証

### セッションベース認証とは

セッションデータで認証情報を運搬する認証方法 (例：Form認証など) である。

システムの各コンポーネントがセッションデータを持つ必要がある。

セッションは有効期限が短く、漏洩した場合に脆弱性が高くなる。

作成と削除が頻繁に起こるコンテナでは、セッションデータが消失する可能性があるため、セッションベース認証とコンテナの相性は悪い。

いずれかのコンポーネントでセッションデータが消失しても復元できるように、SessionStorageを使用する必要がある。

|                                   | セッションベース認証                                                                                                                              | トークンベース認証                                                                                                                                                                                                                                                                             |
| --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Cookie`ヘッダーによる運搬        | セッションデータを認証情報として、`Cookie`ヘッダーで運搬する。セッションデータは、再利用のためにブラウザのCookieに保存する。<br>(例) Form認証など | トークンを認証情報として、`Cookie`ヘッダーで運搬する。トークンは、再利用のためにブラウザのCookieに保存する。認証後にレスポンスのSet-`Cookie`ヘッダーにトークンを設定する必要があり、さまざまなフロントエンドアプリケーション (SST、CSR、SSRなど) で実装できる。<br>(例) OAuth2、OIDC、SAMLなど |
| `Authorization`ヘッダーによる運搬 | なし                                                                                                                                              | トークンを認証情報として、`Authorization`ヘッダーで運搬する。トークンは、再利用のためにブラウザのSessionStorageやLocalStorageに保存する。ブラウザのDOMを操作できるフロントエンドアプリケーション (CSRなど) で実装できる。<br>(例) OAuth2、OIDC、SAML、パーソナルアクセストークン認証など       |

> - https://supertokens.com/blog/token-based-authentication-vs-session-based-authentication
> - https://zenn.dev/oreilly_ota/articles/31d66fab5c184e#%E3%82%BB%E3%83%83%E3%82%B7%E3%83%A7%E3%83%B3%E8%AA%8D%E8%A8%BC%E3%81%A8%E3%83%88%E3%83%BC%E3%82%AF%E3%83%B3%E8%AA%8D%E8%A8%BC%E3%81%AE%E9%81%95%E3%81%84

<br>

### 認証方法の種類

- JWTトークンによる認証
- SSO

<br>

## 02. トークンベース認証

### トークンベース認証とは

トークン (例：JWT仕様あるいはそうではないアクセストークン、IDトークンなど) で認証情報を運搬する認証方法 (例：SSO、パーソナルアクセストークンなど) である。

システムの各コンポーネントはトークンを持つ必要がない。

作成と削除が頻繁に起こるコンテナでは、トークンの消失を考慮する必要がなく、トークンベースとコンテナの相性は良い。

一方で、トークンは無効化が難しく漏洩した場合に脆弱性が高くなる、有効期限を短く設定する必要がある。

|                                   | セッションベース認証                                                                                                                              | トークンベース認証                                                                                                                                                                                                                                                                             |
| --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Cookie`ヘッダーによる運搬        | セッションデータを認証情報として、`Cookie`ヘッダーで運搬する。セッションデータは、再利用のためにブラウザのCookieに保存する。<br>(例) Form認証など | トークンを認証情報として、`Cookie`ヘッダーで運搬する。トークンは、再利用のためにブラウザのCookieに保存する。認証後にレスポンスのSet-`Cookie`ヘッダーにトークンを設定する必要があり、さまざまなフロントエンドアプリケーション (SST、CSR、SSRなど) で実装できる。<br>(例) OAuth2、OIDC、SAMLなど |
| `Authorization`ヘッダーによる運搬 | なし                                                                                                                                              | トークンを認証情報として、`Authorization`ヘッダーで運搬する。トークンは、再利用のためにブラウザのSessionStorageやLocalStorageに保存する。ブラウザのDOMを操作できるフロントエンドアプリケーション (CSRなど) で実装できる。<br>(例) OAuth2、OIDC、SAML、パーソナルアクセストークン認証など       |

> - https://supertokens.com/blog/token-based-authentication-vs-session-based-authentication
> - https://zenn.dev/oreilly_ota/articles/31d66fab5c184e#%E3%82%BB%E3%83%83%E3%82%B7%E3%83%A7%E3%83%B3%E8%AA%8D%E8%A8%BC%E3%81%A8%E3%83%88%E3%83%BC%E3%82%AF%E3%83%B3%E8%AA%8D%E8%A8%BC%E3%81%AE%E9%81%95%E3%81%84

<br>

### 認証方法の種類

- JWTトークンによる認証
- SSO

<br>

### トークン

#### ▼ 種類

トークンには以下の種類がある。

Self-containedトークンでは、トークン自体に署名と有効期限が含まれている。

Opaqueトークンでは、トークンはランダム値で、署名と有効期限はDBで管理されている。

| トークンの種類             | 認証                           | トークンの情報タイプ                                                                |
| -------------------------- | ------------------------------ | ----------------------------------------------------------------------------------- |
| アクセストークン           | OIDC                           | IDプロバイダーのツールによってはJWT仕様 (例：Keycloak) なためSelf-containedトークン |
| IDトークン                 | OIDC                           | 必ずJWT仕様であり、Self-containedトークン                                           |
| リフレッシュトークン       | OAuth2、OIDC                   | Self-containedトークン、Opaqueトークン                                              |
| パーソナルアクセストークン | パーソナルアクセストークン認証 | 記入中...                                                                           |
| XMLベースのトークン        | SAML                           | 記入中...                                                                           |

> - https://qiita.com/TakahikoKawasaki/items/1c1bcf24b46ebd2030f5#%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%83%88%E3%83%BC%E3%82%AF%E3%83%B3jwtid%E3%83%88%E3%83%BC%E3%82%AF%E3%83%B3%E3%81%AE%E5%8C%85%E5%90%AB%E9%96%A2%E4%BF%82
> - https://zenn.dev/mikakane/articles/tutorial_for_openid#oidc-%E5%88%A9%E7%94%A8%E3%81%95%E3%82%8C%E3%82%8B-id-token-%E3%81%AE%E8%A6%8F%E7%B4%84
> - https://medium.com/@iamprovidence/token-gang-bearer-token-reference-token-opaque-token-self-contained-token-jwt-access-token-6e0191093cd0

#### ▼ パーソナルアクセストークン

クライアントがパーソナルアクセストークン (個人用アクセストークン) の付与をリクエストし、認証フェーズは行わずに認可フェーズのみでユーザーを照合する。

`Authorization`ヘッダーにPATを割りあてて、リクエストを送信する。

作成時以降、パーソナルアクセストークンを確認できなくなるため、クライアントがパーソナルアクセストークンを管理する必要がある。

```yaml
POST https://example.com/foo
---
Authorization: <パーソナルアクセストークン>
```

| サービス例 | トークン名                 | 説明                                                                                                                                                                                                                                                                                                  |
| ---------- | -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GitHub     | パーソナルアクセストークン | HTTPSプロトコルを使用して、プライベートリポジトリにリクエストを送信するために必要。HTTPSプロトコルを使用する場面として、アプリケーションの拡張機能のGitHub連携、リポジトリのパッケージ化などがある。<br>- https://docs.github.com/ja/github/authenticating-to-github/creating-a-personal-access-token |

> - https://www.contentful.com/help/personal-access-tokens/
> - https://architecting.hateblo.jp/entry/2020/03/27/033758

<br>

## 03. APIキーベース認証

事前にAPIキーとなる文字列を配布し、認証フェーズは行わずに認可フェーズのみでユーザーを照合する認証スキームのこと。

信頼されたクライアントに発行することが前提のため、トークンよりも有効期限が長い (有効期限がない場合もある) 。

自前ヘッダーとして、`x-api-key`ヘッダーを定義する。これにAPIキーを割り当て、リクエストを送信する。

```yaml
POST https://example.com/foo
---
x-api-key: <APIキー>
```

> - https://architecting.hateblo.jp/entry/2020/03/27/033758
> - https://www.gomomento.com/blog/api-keys-vs-tokens-whats-the-difference

<br>

## 04. 証明書ベース認証

記入中...

<br>

## 05. チケットベース認証

記入中...

<br>

## 06. ワンタイムコードベース認証

記入中...

<br>
